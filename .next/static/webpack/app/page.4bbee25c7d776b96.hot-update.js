"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/pdfGenerator.js":
/*!*********************************!*\
  !*** ./app/lib/pdfGenerator.js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateRetirementReport: function() { return /* binding */ generateRetirementReport; }\n/* harmony export */ });\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jspdf */ \"(app-pages-browser)/./node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jspdf-autotable */ \"(app-pages-browser)/./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs\");\n\n\nconst generateRetirementReport = (formData, calculations)=>{\n    var _formData_expectedReturnType, _formData_expectedReturnType1;\n    const doc = new jspdf__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    // Helper function to format currency\n    const formatCurrency = (value)=>{\n        if (value >= 1000000) {\n            return \"$\".concat((value / 1000000).toFixed(1), \"M\");\n        } else if (value >= 1000) {\n            return \"$\".concat((value / 1000).toFixed(0), \"K\");\n        } else {\n            return \"$\".concat(Math.round(value).toLocaleString());\n        }\n    };\n    const formatFullCurrency = (value)=>{\n        return \"$\".concat(Math.round(value).toLocaleString());\n    };\n    // Extract calculations\n    const { currentAge, retirementAge, yearsToRetirement, currentAnnualIncome, incomeGrowthRate, incomeReplacementRatio, targetMonthlyRetirementIncome, monthlyGovernmentBenefits, netRequiredMonthlyWithdrawal, currentSavings, monthlyContributions, expectedReturn, projectedSavings, monthlyIncomeFromSavings } = calculations;\n    // PAGE 1: SUMMARY\n    doc.setFontSize(20);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Retirement Planning Report\", 20, 30);\n    doc.setFontSize(12);\n    doc.setTextColor(100, 100, 100);\n    doc.text(\"Generated on \".concat(new Date().toLocaleDateString()), 20, 40);\n    // Personal Information Section\n    doc.setFontSize(16);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Personal Information\", 20, 60);\n    doc.setFontSize(11);\n    doc.setTextColor(60, 60, 60);\n    const personalInfo = [\n        [\n            \"Current Age:\",\n            \"\".concat(currentAge, \" years\")\n        ],\n        [\n            \"Retirement Age:\",\n            \"\".concat(retirementAge, \" years\")\n        ],\n        [\n            \"Years to Retirement:\",\n            \"\".concat(yearsToRetirement, \" years\")\n        ],\n        [\n            \"Current Annual Income:\",\n            formatFullCurrency(currentAnnualIncome)\n        ],\n        [\n            \"Income Growth Rate:\",\n            \"\".concat((incomeGrowthRate * 100).toFixed(1), \"%\")\n        ]\n    ];\n    let yPos = 70;\n    personalInfo.forEach((param)=>{\n        let [label, value] = param;\n        doc.text(label, 25, yPos);\n        doc.text(value, 120, yPos);\n        yPos += 8;\n    });\n    // Retirement Goals Section\n    doc.setFontSize(16);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Retirement Goals\", 20, yPos + 10);\n    doc.setFontSize(11);\n    doc.setTextColor(60, 60, 60);\n    yPos += 20;\n    const retirementGoals = [\n        [\n            \"Income Replacement Target:\",\n            \"\".concat(Math.round(incomeReplacementRatio), \"%\")\n        ],\n        [\n            \"Target Monthly Retirement Income:\",\n            formatFullCurrency(targetMonthlyRetirementIncome)\n        ],\n        [\n            \"Monthly Government Benefits:\",\n            formatFullCurrency(monthlyGovernmentBenefits)\n        ],\n        [\n            \"Required Monthly Withdrawal:\",\n            formatFullCurrency(netRequiredMonthlyWithdrawal)\n        ]\n    ];\n    retirementGoals.forEach((param)=>{\n        let [label, value] = param;\n        doc.text(label, 25, yPos);\n        doc.text(value, 120, yPos);\n        yPos += 8;\n    });\n    // Current Financial Position Section\n    doc.setFontSize(16);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Current Financial Position\", 20, yPos + 10);\n    doc.setFontSize(11);\n    doc.setTextColor(60, 60, 60);\n    yPos += 20;\n    const currentPosition = [\n        [\n            \"Current Total Savings:\",\n            formatFullCurrency(currentSavings)\n        ],\n        [\n            \"Monthly Contributions:\",\n            formatFullCurrency(monthlyContributions)\n        ],\n        [\n            \"Expected Return:\",\n            \"\".concat((expectedReturn * 100).toFixed(1), \"%\")\n        ],\n        [\n            \"Investment Risk Profile:\",\n            ((_formData_expectedReturnType = formData.expectedReturnType) === null || _formData_expectedReturnType === void 0 ? void 0 : _formData_expectedReturnType.charAt(0).toUpperCase()) + ((_formData_expectedReturnType1 = formData.expectedReturnType) === null || _formData_expectedReturnType1 === void 0 ? void 0 : _formData_expectedReturnType1.slice(1)) || \"Not specified\"\n        ]\n    ];\n    currentPosition.forEach((param)=>{\n        let [label, value] = param;\n        doc.text(label, 25, yPos);\n        doc.text(value, 120, yPos);\n        yPos += 8;\n    });\n    // Projection Results Section\n    doc.setFontSize(16);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Projection Results\", 20, yPos + 10);\n    doc.setFontSize(11);\n    doc.setTextColor(60, 60, 60);\n    yPos += 20;\n    const projectionResults = [\n        [\n            \"Projected Savings at Retirement:\",\n            formatCurrency(projectedSavings)\n        ],\n        [\n            \"Monthly Income from Savings:\",\n            formatFullCurrency(monthlyIncomeFromSavings)\n        ],\n        [\n            \"Total Monthly Retirement Income:\",\n            formatFullCurrency(monthlyIncomeFromSavings + monthlyGovernmentBenefits)\n        ],\n        [\n            \"Sustainability Rate:\",\n            \"\".concat(Math.min(100, Math.max(0, monthlyIncomeFromSavings / netRequiredMonthlyWithdrawal * 100)).toFixed(1), \"%\")\n        ]\n    ];\n    projectionResults.forEach((param)=>{\n        let [label, value] = param;\n        doc.text(label, 25, yPos);\n        doc.text(value, 120, yPos);\n        yPos += 8;\n    });\n    // PAGE 2: PRE-RETIREMENT PROJECTIONS\n    doc.addPage();\n    doc.setFontSize(20);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Year-by-Year Projections\", 20, 30);\n    doc.setFontSize(14);\n    doc.text(\"Pre-Retirement Phase\", 20, 45);\n    // Generate year-by-year data for pre-retirement\n    const preRetirementData = [];\n    const currentYear = new Date().getFullYear();\n    for(let i = 0; i <= yearsToRetirement; i++){\n        const year = currentYear + i;\n        const age = currentAge + i;\n        const annualIncome = currentAnnualIncome * Math.pow(1 + incomeGrowthRate, i);\n        // Calculate year-end balance with compound interest\n        let yearEndBalance = 0;\n        let investmentReturn = 0;\n        if (i === 0) {\n            investmentReturn = currentSavings * expectedReturn;\n            yearEndBalance = currentSavings * (1 + expectedReturn) + monthlyContributions * 12;\n        } else {\n            // Previous year's balance - need to extract numeric value from formatted string\n            const prevBalanceStr = preRetirementData[i - 1][5];\n            const prevBalance = parseFloat(prevBalanceStr.replace(/[$,]/g, \"\"));\n            investmentReturn = prevBalance * expectedReturn;\n            yearEndBalance = prevBalance * (1 + expectedReturn) + monthlyContributions * 12;\n        }\n        preRetirementData.push([\n            year,\n            age,\n            formatFullCurrency(annualIncome),\n            formatFullCurrency(monthlyContributions * 12),\n            formatFullCurrency(investmentReturn),\n            formatFullCurrency(yearEndBalance)\n        ]);\n    }\n    // Create table for pre-retirement projections\n    doc.autoTable({\n        head: [\n            [\n                \"Year\",\n                \"Age\",\n                \"Annual Income\",\n                \"Annual Contribution\",\n                \"Investment Return\",\n                \"Year-End Balance\"\n            ]\n        ],\n        body: preRetirementData,\n        startY: 55,\n        theme: \"grid\",\n        headStyles: {\n            fillColor: [\n                41,\n                128,\n                185\n            ],\n            textColor: 255,\n            fontSize: 10\n        },\n        bodyStyles: {\n            fontSize: 9\n        },\n        columnStyles: {\n            0: {\n                cellWidth: 25\n            },\n            1: {\n                cellWidth: 25\n            },\n            2: {\n                cellWidth: 35\n            },\n            3: {\n                cellWidth: 35\n            },\n            4: {\n                cellWidth: 35\n            },\n            5: {\n                cellWidth: 35\n            }\n        }\n    });\n    // PAGE 3: POST-RETIREMENT WITHDRAWALS\n    doc.addPage();\n    doc.setFontSize(20);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Post-Retirement Withdrawals\", 20, 30);\n    doc.setFontSize(14);\n    doc.text(\"Retirement Phase (Age 70-95)\", 20, 45);\n    // Generate post-retirement withdrawal data\n    const postRetirementData = [];\n    let remainingBalance = projectedSavings;\n    const annualWithdrawal = netRequiredMonthlyWithdrawal * 12;\n    const monthlyWithdrawal = netRequiredMonthlyWithdrawal;\n    for(let age = retirementAge; age <= 95; age++){\n        const year = currentYear + (age - currentAge);\n        // Calculate balance after withdrawal and growth\n        const balanceAfterWithdrawal = Math.max(0, remainingBalance - annualWithdrawal);\n        const growthOnRemainingBalance = balanceAfterWithdrawal * expectedReturn;\n        const yearEndBalance = balanceAfterWithdrawal + growthOnRemainingBalance;\n        postRetirementData.push([\n            year,\n            age,\n            formatFullCurrency(annualWithdrawal),\n            formatFullCurrency(monthlyWithdrawal),\n            formatFullCurrency(growthOnRemainingBalance),\n            formatFullCurrency(yearEndBalance)\n        ]);\n        remainingBalance = yearEndBalance;\n        // Stop if balance reaches zero\n        if (remainingBalance <= 0) break;\n    }\n    // Create table for post-retirement withdrawals\n    doc.autoTable({\n        head: [\n            [\n                \"Year\",\n                \"Age\",\n                \"Annual Withdrawal\",\n                \"Monthly Withdrawal\",\n                \"Investment Growth\",\n                \"Year-End Balance\"\n            ]\n        ],\n        body: postRetirementData,\n        startY: 55,\n        theme: \"grid\",\n        headStyles: {\n            fillColor: [\n                231,\n                76,\n                60\n            ],\n            textColor: 255,\n            fontSize: 10\n        },\n        bodyStyles: {\n            fontSize: 9\n        },\n        columnStyles: {\n            0: {\n                cellWidth: 25\n            },\n            1: {\n                cellWidth: 25\n            },\n            2: {\n                cellWidth: 35\n            },\n            3: {\n                cellWidth: 35\n            },\n            4: {\n                cellWidth: 35\n            },\n            5: {\n                cellWidth: 35\n            }\n        }\n    });\n    // Add footer to all pages\n    const pageCount = doc.internal.getNumberOfPages();\n    for(let i = 1; i <= pageCount; i++){\n        doc.setPage(i);\n        doc.setFontSize(8);\n        doc.setTextColor(150, 150, 150);\n        doc.text(\"Page \".concat(i, \" of \").concat(pageCount), 20, 285);\n        doc.text(\"This report is for illustrative purposes only and should not be considered as financial advice.\", 20, 292);\n    }\n    // Save the PDF\n    doc.save(\"retirement-planning-report.pdf\");\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvcGRmR2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQjtBQUNjO0FBRWpDLE1BQU1FLDJCQUEyQixDQUFDQyxVQUFVQztRQW9HbEJELDhCQUF1REE7SUFuR3RGLE1BQU1FLE1BQU0sSUFBSUwsNkNBQUtBO0lBRXJCLHFDQUFxQztJQUNyQyxNQUFNTSxpQkFBaUIsQ0FBQ0M7UUFDdEIsSUFBSUEsU0FBUyxTQUFTO1lBQ3BCLE9BQU8sSUFBaUMsT0FBN0IsQ0FBQ0EsUUFBUSxPQUFNLEVBQUdDLE9BQU8sQ0FBQyxJQUFHO1FBQzFDLE9BQU8sSUFBSUQsU0FBUyxNQUFNO1lBQ3hCLE9BQU8sSUFBOEIsT0FBMUIsQ0FBQ0EsUUFBUSxJQUFHLEVBQUdDLE9BQU8sQ0FBQyxJQUFHO1FBQ3ZDLE9BQU87WUFDTCxPQUFPLElBQXVDLE9BQW5DQyxLQUFLQyxLQUFLLENBQUNILE9BQU9JLGNBQWM7UUFDN0M7SUFDRjtJQUVBLE1BQU1DLHFCQUFxQixDQUFDTDtRQUMxQixPQUFPLElBQXVDLE9BQW5DRSxLQUFLQyxLQUFLLENBQUNILE9BQU9JLGNBQWM7SUFDN0M7SUFFQSx1QkFBdUI7SUFDdkIsTUFBTSxFQUNKRSxVQUFVLEVBQ1ZDLGFBQWEsRUFDYkMsaUJBQWlCLEVBQ2pCQyxtQkFBbUIsRUFDbkJDLGdCQUFnQixFQUNoQkMsc0JBQXNCLEVBQ3RCQyw2QkFBNkIsRUFDN0JDLHlCQUF5QixFQUN6QkMsNEJBQTRCLEVBQzVCQyxjQUFjLEVBQ2RDLG9CQUFvQixFQUNwQkMsY0FBYyxFQUNkQyxnQkFBZ0IsRUFDaEJDLHdCQUF3QixFQUN6QixHQUFHdEI7SUFFSixrQkFBa0I7SUFDbEJDLElBQUlzQixXQUFXLENBQUM7SUFDaEJ0QixJQUFJdUIsWUFBWSxDQUFDLElBQUksSUFBSTtJQUN6QnZCLElBQUl3QixJQUFJLENBQUMsOEJBQThCLElBQUk7SUFFM0N4QixJQUFJc0IsV0FBVyxDQUFDO0lBQ2hCdEIsSUFB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QzNHQyxNQUFNVTtRQUNOVCxRQUFRO1FBQ1JDLE9BQU87UUFDUEMsWUFBWTtZQUFFQyxXQUFXO2dCQUFDO2dCQUFLO2dCQUFJO2FBQUc7WUFBRUMsV0FBVztZQUFLQyxVQUFVO1FBQUc7UUFDckVDLFlBQVk7WUFBRUQsVUFBVTtRQUFFO1FBQzFCRSxjQUFjO1lBQ1osR0FBRztnQkFBRUMsV0FBVztZQUFHO1lBQ25CLEdBQUc7Z0JBQUVBLFdBQVc7WUFBRztZQUNuQixHQUFHO2dCQUFFQSxXQUFXO1lBQUc7WUFDbkIsR0FBRztnQkFBRUEsV0FBVztZQUFHO1lBQ25CLEdBQUc7Z0JBQUVBLFdBQVc7WUFBRztZQUNuQixHQUFHO2dCQUFFQSxXQUFXO1lBQUc7UUFDckI7SUFDRjtJQUVBLDBCQUEwQjtJQUMxQixNQUFNTyxZQUFZekUsSUFBSTBFLFFBQVEsQ0FBQ0MsZ0JBQWdCO0lBQy9DLElBQUssSUFBSS9CLElBQUksR0FBR0EsS0FBSzZCLFdBQVc3QixJQUFLO1FBQ25DNUMsSUFBSTRFLE9BQU8sQ0FBQ2hDO1FBQ1o1QyxJQUFJc0IsV0FBVyxDQUFDO1FBQ2hCdEIsSUFBSXVCLFlBQVksQ0FBQyxLQUFLLEtBQUs7UUFDM0J2QixJQUFJd0IsSUFBSSxDQUFDLFFBQWdCaUQsT0FBUjdCLEdBQUUsUUFBZ0IsT0FBVjZCLFlBQWEsSUFBSTtRQUMxQ3pFLElBQUl3QixJQUFJLENBQUMsbUdBQW1HLElBQUk7SUFDbEg7SUFFQSxlQUFlO0lBQ2Z4QixJQUFJNkUsSUFBSSxDQUFDO0FBQ1gsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL3BkZkdlbmVyYXRvci5qcz8wNzI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBqc1BERiBmcm9tICdqc3BkZic7XG5pbXBvcnQgYXV0b1RhYmxlIGZyb20gJ2pzcGRmLWF1dG90YWJsZSc7XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVJldGlyZW1lbnRSZXBvcnQgPSAoZm9ybURhdGEsIGNhbGN1bGF0aW9ucykgPT4ge1xuICBjb25zdCBkb2MgPSBuZXcganNQREYoKTtcbiAgXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBmb3JtYXQgY3VycmVuY3lcbiAgY29uc3QgZm9ybWF0Q3VycmVuY3kgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPj0gMTAwMDAwMCkge1xuICAgICAgcmV0dXJuIGAkJHsodmFsdWUgLyAxMDAwMDAwKS50b0ZpeGVkKDEpfU1gO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPj0gMTAwMCkge1xuICAgICAgcmV0dXJuIGAkJHsodmFsdWUgLyAxMDAwKS50b0ZpeGVkKDApfUtgO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCQke01hdGgucm91bmQodmFsdWUpLnRvTG9jYWxlU3RyaW5nKCl9YDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZm9ybWF0RnVsbEN1cnJlbmN5ID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGAkJHtNYXRoLnJvdW5kKHZhbHVlKS50b0xvY2FsZVN0cmluZygpfWA7XG4gIH07XG5cbiAgLy8gRXh0cmFjdCBjYWxjdWxhdGlvbnNcbiAgY29uc3Qge1xuICAgIGN1cnJlbnRBZ2UsXG4gICAgcmV0aXJlbWVudEFnZSxcbiAgICB5ZWFyc1RvUmV0aXJlbWVudCxcbiAgICBjdXJyZW50QW5udWFsSW5jb21lLFxuICAgIGluY29tZUdyb3d0aFJhdGUsXG4gICAgaW5jb21lUmVwbGFjZW1lbnRSYXRpbyxcbiAgICB0YXJnZXRNb250aGx5UmV0aXJlbWVudEluY29tZSxcbiAgICBtb250aGx5R292ZXJubWVudEJlbmVmaXRzLFxuICAgIG5ldFJlcXVpcmVkTW9udGhseVdpdGhkcmF3YWwsXG4gICAgY3VycmVudFNhdmluZ3MsXG4gICAgbW9udGhseUNvbnRyaWJ1dGlvbnMsXG4gICAgZXhwZWN0ZWRSZXR1cm4sXG4gICAgcHJvamVjdGVkU2F2aW5ncyxcbiAgICBtb250aGx5SW5jb21lRnJvbVNhdmluZ3NcbiAgfSA9IGNhbGN1bGF0aW9ucztcblxuICAvLyBQQUdFIDE6IFNVTU1BUllcbiAgZG9jLnNldEZvbnRTaXplKDIwKTtcbiAgZG9jLnNldFRleHRDb2xvcig0MCwgNDAsIDQwKTtcbiAgZG9jLnRleHQoJ1JldGlyZW1lbnQgUGxhbm5pbmcgUmVwb3J0JywgMjAsIDMwKTtcbiAgXG4gIGRvYy5zZXRGb250U2l6ZSgxMik7XG4gIGRvYy5zZXRUZXh0Q29sb3IoMTAwLCAxMDAsIDEwMCk7XG4gIGRvYy50ZXh0KGBHZW5lcmF0ZWQgb24gJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfWAsIDIwLCA0MCk7XG5cbiAgLy8gUGVyc29uYWwgSW5mb3JtYXRpb24gU2VjdGlvblxuICBkb2Muc2V0Rm9udFNpemUoMTYpO1xuICBkb2Muc2V0VGV4dENvbG9yKDQwLCA0MCwgNDApO1xuICBkb2MudGV4dCgnUGVyc29uYWwgSW5mb3JtYXRpb24nLCAyMCwgNjApO1xuICBcbiAgZG9jLnNldEZvbnRTaXplKDExKTtcbiAgZG9jLnNldFRleHRDb2xvcig2MCwgNjAsIDYwKTtcbiAgY29uc3QgcGVyc29uYWxJbmZvID0gW1xuICAgIFsnQ3VycmVudCBBZ2U6JywgYCR7Y3VycmVudEFnZX0geWVhcnNgXSxcbiAgICBbJ1JldGlyZW1lbnQgQWdlOicsIGAke3JldGlyZW1lbnRBZ2V9IHllYXJzYF0sXG4gICAgWydZZWFycyB0byBSZXRpcmVtZW50OicsIGAke3llYXJzVG9SZXRpcmVtZW50fSB5ZWFyc2BdLFxuICAgIFsnQ3VycmVudCBBbm51YWwgSW5jb21lOicsIGZvcm1hdEZ1bGxDdXJyZW5jeShjdXJyZW50QW5udWFsSW5jb21lKV0sXG4gICAgWydJbmNvbWUgR3Jvd3RoIFJhdGU6JywgYCR7KGluY29tZUdyb3d0aFJhdGUgKiAxMDApLnRvRml4ZWQoMSl9JWBdXG4gIF07XG4gIFxuICBsZXQgeVBvcyA9IDcwO1xuICBwZXJzb25hbEluZm8uZm9yRWFjaCgoW2xhYmVsLCB2YWx1ZV0pID0+IHtcbiAgICBkb2MudGV4dChsYWJlbCwgMjUsIHlQb3MpO1xuICAgIGRvYy50ZXh0KHZhbHVlLCAxMjAsIHlQb3MpO1xuICAgIHlQb3MgKz0gODtcbiAgfSk7XG5cbiAgLy8gUmV0aXJlbWVudCBHb2FscyBTZWN0aW9uXG4gIGRvYy5zZXRGb250U2l6ZSgxNik7XG4gIGRvYy5zZXRUZXh0Q29sb3IoNDAsIDQwLCA0MCk7XG4gIGRvYy50ZXh0KCdSZXRpcmVtZW50IEdvYWxzJywgMjAsIHlQb3MgKyAxMCk7XG4gIFxuICBkb2Muc2V0Rm9udFNpemUoMTEpO1xuICBkb2Muc2V0VGV4dENvbG9yKDYwLCA2MCwgNjApO1xuICB5UG9zICs9IDIwO1xuICBjb25zdCByZXRpcmVtZW50R29hbHMgPSBbXG4gICAgWydJbmNvbWUgUmVwbGFjZW1lbnQgVGFyZ2V0OicsIGAke01hdGgucm91bmQoaW5jb21lUmVwbGFjZW1lbnRSYXRpbyl9JWBdLFxuICAgIFsnVGFyZ2V0IE1vbnRobHkgUmV0aXJlbWVudCBJbmNvbWU6JywgZm9ybWF0RnVsbEN1cnJlbmN5KHRhcmdldE1vbnRobHlSZXRpcmVtZW50SW5jb21lKV0sXG4gICAgWydNb250aGx5IEdvdmVybm1lbnQgQmVuZWZpdHM6JywgZm9ybWF0RnVsbEN1cnJlbmN5KG1vbnRobHlHb3Zlcm5tZW50QmVuZWZpdHMpXSxcbiAgICBbJ1JlcXVpcmVkIE1vbnRobHkgV2l0aGRyYXdhbDonLCBmb3JtYXRGdWxsQ3VycmVuY3kobmV0UmVxdWlyZWRNb250aGx5V2l0aGRyYXdhbCldXG4gIF07XG4gIFxuICByZXRpcmVtZW50R29hbHMuZm9yRWFjaCgoW2xhYmVsLCB2YWx1ZV0pID0+IHtcbiAgICBkb2MudGV4dChsYWJlbCwgMjUsIHlQb3MpO1xuICAgIGRvYy50ZXh0KHZhbHVlLCAxMjAsIHlQb3MpO1xuICAgIHlQb3MgKz0gODtcbiAgfSk7XG5cbiAgLy8gQ3VycmVudCBGaW5hbmNpYWwgUG9zaXRpb24gU2VjdGlvblxuICBkb2Muc2V0Rm9udFNpemUoMTYpO1xuICBkb2Muc2V0VGV4dENvbG9yKDQwLCA0MCwgNDApO1xuICBkb2MudGV4dCgnQ3VycmVudCBGaW5hbmNpYWwgUG9zaXRpb24nLCAyMCwgeVBvcyArIDEwKTtcbiAgXG4gIGRvYy5zZXRGb250U2l6ZSgxMSk7XG4gIGRvYy5zZXRUZXh0Q29sb3IoNjAsIDYwLCA2MCk7XG4gIHlQb3MgKz0gMjA7XG4gIGNvbnN0IGN1cnJlbnRQb3NpdGlvbiA9IFtcbiAgICBbJ0N1cnJlbnQgVG90YWwgU2F2aW5nczonLCBmb3JtYXRGdWxsQ3VycmVuY3koY3VycmVudFNhdmluZ3MpXSxcbiAgICBbJ01vbnRobHkgQ29udHJpYnV0aW9uczonLCBmb3JtYXRGdWxsQ3VycmVuY3kobW9udGhseUNvbnRyaWJ1dGlvbnMpXSxcbiAgICBbJ0V4cGVjdGVkIFJldHVybjonLCBgJHsoZXhwZWN0ZWRSZXR1cm4gKiAxMDApLnRvRml4ZWQoMSl9JWBdLFxuICAgIFsnSW52ZXN0bWVudCBSaXNrIFByb2ZpbGU6JywgZm9ybURhdGEuZXhwZWN0ZWRSZXR1cm5UeXBlPy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGZvcm1EYXRhLmV4cGVjdGVkUmV0dXJuVHlwZT8uc2xpY2UoMSkgfHwgJ05vdCBzcGVjaWZpZWQnXVxuICBdO1xuICBcbiAgY3VycmVudFBvc2l0aW9uLmZvckVhY2goKFtsYWJlbCwgdmFsdWVdKSA9PiB7XG4gICAgZG9jLnRleHQobGFiZWwsIDI1LCB5UG9zKTtcbiAgICBkb2MudGV4dCh2YWx1ZSwgMTIwLCB5UG9zKTtcbiAgICB5UG9zICs9IDg7XG4gIH0pO1xuXG4gIC8vIFByb2plY3Rpb24gUmVzdWx0cyBTZWN0aW9uXG4gIGRvYy5zZXRGb250U2l6ZSgxNik7XG4gIGRvYy5zZXRUZXh0Q29sb3IoNDAsIDQwLCA0MCk7XG4gIGRvYy50ZXh0KCdQcm9qZWN0aW9uIFJlc3VsdHMnLCAyMCwgeVBvcyArIDEwKTtcbiAgXG4gIGRvYy5zZXRGb250U2l6ZSgxMSk7XG4gIGRvYy5zZXRUZXh0Q29sb3IoNjAsIDYwLCA2MCk7XG4gIHlQb3MgKz0gMjA7XG4gIGNvbnN0IHByb2plY3Rpb25SZXN1bHRzID0gW1xuICAgIFsnUHJvamVjdGVkIFNhdmluZ3MgYXQgUmV0aXJlbWVudDonLCBmb3JtYXRDdXJyZW5jeShwcm9qZWN0ZWRTYXZpbmdzKV0sXG4gICAgWydNb250aGx5IEluY29tZSBmcm9tIFNhdmluZ3M6JywgZm9ybWF0RnVsbEN1cnJlbmN5KG1vbnRobHlJbmNvbWVGcm9tU2F2aW5ncyldLFxuICAgIFsnVG90YWwgTW9udGhseSBSZXRpcmVtZW50IEluY29tZTonLCBmb3JtYXRGdWxsQ3VycmVuY3kobW9udGhseUluY29tZUZyb21TYXZpbmdzICsgbW9udGhseUdvdmVybm1lbnRCZW5lZml0cyldLFxuICAgIFsnU3VzdGFpbmFiaWxpdHkgUmF0ZTonLCBgJHtNYXRoLm1pbigxMDAsIE1hdGgubWF4KDAsIChtb250aGx5SW5jb21lRnJvbVNhdmluZ3MgLyBuZXRSZXF1aXJlZE1vbnRobHlXaXRoZHJhd2FsKSAqIDEwMCkpLnRvRml4ZWQoMSl9JWBdXG4gIF07XG4gIFxuICBwcm9qZWN0aW9uUmVzdWx0cy5mb3JFYWNoKChbbGFiZWwsIHZhbHVlXSkgPT4ge1xuICAgIGRvYy50ZXh0KGxhYmVsLCAyNSwgeVBvcyk7XG4gICAgZG9jLnRleHQodmFsdWUsIDEyMCwgeVBvcyk7XG4gICAgeVBvcyArPSA4O1xuICB9KTtcblxuICAvLyBQQUdFIDI6IFBSRS1SRVRJUkVNRU5UIFBST0pFQ1RJT05TXG4gIGRvYy5hZGRQYWdlKCk7XG4gIGRvYy5zZXRGb250U2l6ZSgyMCk7XG4gIGRvYy5zZXRUZXh0Q29sb3IoNDAsIDQwLCA0MCk7XG4gIGRvYy50ZXh0KCdZZWFyLWJ5LVllYXIgUHJvamVjdGlvbnMnLCAyMCwgMzApO1xuICBcbiAgZG9jLnNldEZvbnRTaXplKDE0KTtcbiAgZG9jLnRleHQoJ1ByZS1SZXRpcmVtZW50IFBoYXNlJywgMjAsIDQ1KTtcblxuICAvLyBHZW5lcmF0ZSB5ZWFyLWJ5LXllYXIgZGF0YSBmb3IgcHJlLXJldGlyZW1lbnRcbiAgY29uc3QgcHJlUmV0aXJlbWVudERhdGEgPSBbXTtcbiAgY29uc3QgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8PSB5ZWFyc1RvUmV0aXJlbWVudDsgaSsrKSB7XG4gICAgY29uc3QgeWVhciA9IGN1cnJlbnRZZWFyICsgaTtcbiAgICBjb25zdCBhZ2UgPSBjdXJyZW50QWdlICsgaTtcbiAgICBjb25zdCBhbm51YWxJbmNvbWUgPSBjdXJyZW50QW5udWFsSW5jb21lICogTWF0aC5wb3coMSArIGluY29tZUdyb3d0aFJhdGUsIGkpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB5ZWFyLWVuZCBiYWxhbmNlIHdpdGggY29tcG91bmQgaW50ZXJlc3RcbiAgICBsZXQgeWVhckVuZEJhbGFuY2UgPSAwO1xuICAgIGxldCBpbnZlc3RtZW50UmV0dXJuID0gMDtcbiAgICBcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgaW52ZXN0bWVudFJldHVybiA9IGN1cnJlbnRTYXZpbmdzICogZXhwZWN0ZWRSZXR1cm47XG4gICAgICB5ZWFyRW5kQmFsYW5jZSA9IGN1cnJlbnRTYXZpbmdzICogKDEgKyBleHBlY3RlZFJldHVybikgKyAobW9udGhseUNvbnRyaWJ1dGlvbnMgKiAxMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByZXZpb3VzIHllYXIncyBiYWxhbmNlIC0gbmVlZCB0byBleHRyYWN0IG51bWVyaWMgdmFsdWUgZnJvbSBmb3JtYXR0ZWQgc3RyaW5nXG4gICAgICBjb25zdCBwcmV2QmFsYW5jZVN0ciA9IHByZVJldGlyZW1lbnREYXRhW2ktMV1bNV07XG4gICAgICBjb25zdCBwcmV2QmFsYW5jZSA9IHBhcnNlRmxvYXQocHJldkJhbGFuY2VTdHIucmVwbGFjZSgvWyQsXS9nLCAnJykpO1xuICAgICAgaW52ZXN0bWVudFJldHVybiA9IHByZXZCYWxhbmNlICogZXhwZWN0ZWRSZXR1cm47XG4gICAgICB5ZWFyRW5kQmFsYW5jZSA9IHByZXZCYWxhbmNlICogKDEgKyBleHBlY3RlZFJldHVybikgKyAobW9udGhseUNvbnRyaWJ1dGlvbnMgKiAxMik7XG4gICAgfVxuICAgIFxuICAgIHByZVJldGlyZW1lbnREYXRhLnB1c2goW1xuICAgICAgeWVhcixcbiAgICAgIGFnZSxcbiAgICAgIGZvcm1hdEZ1bGxDdXJyZW5jeShhbm51YWxJbmNvbWUpLFxuICAgICAgZm9ybWF0RnVsbEN1cnJlbmN5KG1vbnRobHlDb250cmlidXRpb25zICogMTIpLFxuICAgICAgZm9ybWF0RnVsbEN1cnJlbmN5KGludmVzdG1lbnRSZXR1cm4pLFxuICAgICAgZm9ybWF0RnVsbEN1cnJlbmN5KHllYXJFbmRCYWxhbmNlKVxuICAgIF0pO1xuICB9XG5cbiAgLy8gQ3JlYXRlIHRhYmxlIGZvciBwcmUtcmV0aXJlbWVudCBwcm9qZWN0aW9uc1xuICBkb2MuYXV0b1RhYmxlKHtcbiAgICBoZWFkOiBbWydZZWFyJywgJ0FnZScsICdBbm51YWwgSW5jb21lJywgJ0FubnVhbCBDb250cmlidXRpb24nLCAnSW52ZXN0bWVudCBSZXR1cm4nLCAnWWVhci1FbmQgQmFsYW5jZSddXSxcbiAgICBib2R5OiBwcmVSZXRpcmVtZW50RGF0YSxcbiAgICBzdGFydFk6IDU1LFxuICAgIHRoZW1lOiAnZ3JpZCcsXG4gICAgaGVhZFN0eWxlczogeyBmaWxsQ29sb3I6IFs0MSwgMTI4LCAxODVdLCB0ZXh0Q29sb3I6IDI1NSwgZm9udFNpemU6IDEwIH0sXG4gICAgYm9keVN0eWxlczogeyBmb250U2l6ZTogOSB9LFxuICAgIGNvbHVtblN0eWxlczoge1xuICAgICAgMDogeyBjZWxsV2lkdGg6IDI1IH0sXG4gICAgICAxOiB7IGNlbGxXaWR0aDogMjUgfSxcbiAgICAgIDI6IHsgY2VsbFdpZHRoOiAzNSB9LFxuICAgICAgMzogeyBjZWxsV2lkdGg6IDM1IH0sXG4gICAgICA0OiB7IGNlbGxXaWR0aDogMzUgfSxcbiAgICAgIDU6IHsgY2VsbFdpZHRoOiAzNSB9XG4gICAgfVxuICB9KTtcblxuICAvLyBQQUdFIDM6IFBPU1QtUkVUSVJFTUVOVCBXSVRIRFJBV0FMU1xuICBkb2MuYWRkUGFnZSgpO1xuICBkb2Muc2V0Rm9udFNpemUoMjApO1xuICBkb2Muc2V0VGV4dENvbG9yKDQwLCA0MCwgNDApO1xuICBkb2MudGV4dCgnUG9zdC1SZXRpcmVtZW50IFdpdGhkcmF3YWxzJywgMjAsIDMwKTtcbiAgXG4gIGRvYy5zZXRGb250U2l6ZSgxNCk7XG4gIGRvYy50ZXh0KCdSZXRpcmVtZW50IFBoYXNlIChBZ2UgNzAtOTUpJywgMjAsIDQ1KTtcblxuICAvLyBHZW5lcmF0ZSBwb3N0LXJldGlyZW1lbnQgd2l0aGRyYXdhbCBkYXRhXG4gIGNvbnN0IHBvc3RSZXRpcmVtZW50RGF0YSA9IFtdO1xuICBsZXQgcmVtYWluaW5nQmFsYW5jZSA9IHByb2plY3RlZFNhdmluZ3M7XG4gIGNvbnN0IGFubnVhbFdpdGhkcmF3YWwgPSBuZXRSZXF1aXJlZE1vbnRobHlXaXRoZHJhd2FsICogMTI7XG4gIGNvbnN0IG1vbnRobHlXaXRoZHJhd2FsID0gbmV0UmVxdWlyZWRNb250aGx5V2l0aGRyYXdhbDtcbiAgXG4gIGZvciAobGV0IGFnZSA9IHJldGlyZW1lbnRBZ2U7IGFnZSA8PSA5NTsgYWdlKyspIHtcbiAgICBjb25zdCB5ZWFyID0gY3VycmVudFllYXIgKyAoYWdlIC0gY3VycmVudEFnZSk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGJhbGFuY2UgYWZ0ZXIgd2l0aGRyYXdhbCBhbmQgZ3Jvd3RoXG4gICAgY29uc3QgYmFsYW5jZUFmdGVyV2l0aGRyYXdhbCA9IE1hdGgubWF4KDAsIHJlbWFpbmluZ0JhbGFuY2UgLSBhbm51YWxXaXRoZHJhd2FsKTtcbiAgICBjb25zdCBncm93dGhPblJlbWFpbmluZ0JhbGFuY2UgPSBiYWxhbmNlQWZ0ZXJXaXRoZHJhd2FsICogZXhwZWN0ZWRSZXR1cm47XG4gICAgY29uc3QgeWVhckVuZEJhbGFuY2UgPSBiYWxhbmNlQWZ0ZXJXaXRoZHJhd2FsICsgZ3Jvd3RoT25SZW1haW5pbmdCYWxhbmNlO1xuICAgIFxuICAgIHBvc3RSZXRpcmVtZW50RGF0YS5wdXNoKFtcbiAgICAgIHllYXIsXG4gICAgICBhZ2UsXG4gICAgICBmb3JtYXRGdWxsQ3VycmVuY3koYW5udWFsV2l0aGRyYXdhbCksXG4gICAgICBmb3JtYXRGdWxsQ3VycmVuY3kobW9udGhseVdpdGhkcmF3YWwpLFxuICAgICAgZm9ybWF0RnVsbEN1cnJlbmN5KGdyb3d0aE9uUmVtYWluaW5nQmFsYW5jZSksXG4gICAgICBmb3JtYXRGdWxsQ3VycmVuY3koeWVhckVuZEJhbGFuY2UpXG4gICAgXSk7XG4gICAgXG4gICAgcmVtYWluaW5nQmFsYW5jZSA9IHllYXJFbmRCYWxhbmNlO1xuICAgIFxuICAgIC8vIFN0b3AgaWYgYmFsYW5jZSByZWFjaGVzIHplcm9cbiAgICBpZiAocmVtYWluaW5nQmFsYW5jZSA8PSAwKSBicmVhaztcbiAgfVxuXG4gIC8vIENyZWF0ZSB0YWJsZSBmb3IgcG9zdC1yZXRpcmVtZW50IHdpdGhkcmF3YWxzXG4gIGRvYy5hdXRvVGFibGUoe1xuICAgIGhlYWQ6IFtbJ1llYXInLCAnQWdlJywgJ0FubnVhbCBXaXRoZHJhd2FsJywgJ01vbnRobHkgV2l0aGRyYXdhbCcsICdJbnZlc3RtZW50IEdyb3d0aCcsICdZZWFyLUVuZCBCYWxhbmNlJ11dLFxuICAgIGJvZHk6IHBvc3RSZXRpcmVtZW50RGF0YSxcbiAgICBzdGFydFk6IDU1LFxuICAgIHRoZW1lOiAnZ3JpZCcsXG4gICAgaGVhZFN0eWxlczogeyBmaWxsQ29sb3I6IFsyMzEsIDc2LCA2MF0sIHRleHRDb2xvcjogMjU1LCBmb250U2l6ZTogMTAgfSxcbiAgICBib2R5U3R5bGVzOiB7IGZvbnRTaXplOiA5IH0sXG4gICAgY29sdW1uU3R5bGVzOiB7XG4gICAgICAwOiB7IGNlbGxXaWR0aDogMjUgfSxcbiAgICAgIDE6IHsgY2VsbFdpZHRoOiAyNSB9LFxuICAgICAgMjogeyBjZWxsV2lkdGg6IDM1IH0sXG4gICAgICAzOiB7IGNlbGxXaWR0aDogMzUgfSxcbiAgICAgIDQ6IHsgY2VsbFdpZHRoOiAzNSB9LFxuICAgICAgNTogeyBjZWxsV2lkdGg6IDM1IH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIEFkZCBmb290ZXIgdG8gYWxsIHBhZ2VzXG4gIGNvbnN0IHBhZ2VDb3VudCA9IGRvYy5pbnRlcm5hbC5nZXROdW1iZXJPZlBhZ2VzKCk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IHBhZ2VDb3VudDsgaSsrKSB7XG4gICAgZG9jLnNldFBhZ2UoaSk7XG4gICAgZG9jLnNldEZvbnRTaXplKDgpO1xuICAgIGRvYy5zZXRUZXh0Q29sb3IoMTUwLCAxNTAsIDE1MCk7XG4gICAgZG9jLnRleHQoYFBhZ2UgJHtpfSBvZiAke3BhZ2VDb3VudH1gLCAyMCwgMjg1KTtcbiAgICBkb2MudGV4dCgnVGhpcyByZXBvcnQgaXMgZm9yIGlsbHVzdHJhdGl2ZSBwdXJwb3NlcyBvbmx5IGFuZCBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgYXMgZmluYW5jaWFsIGFkdmljZS4nLCAyMCwgMjkyKTtcbiAgfVxuXG4gIC8vIFNhdmUgdGhlIFBERlxuICBkb2Muc2F2ZSgncmV0aXJlbWVudC1wbGFubmluZy1yZXBvcnQucGRmJyk7XG59OyAiXSwibmFtZXMiOlsianNQREYiLCJhdXRvVGFibGUiLCJnZW5lcmF0ZVJldGlyZW1lbnRSZXBvcnQiLCJmb3JtRGF0YSIsImNhbGN1bGF0aW9ucyIsImRvYyIsImZvcm1hdEN1cnJlbmN5IiwidmFsdWUiLCJ0b0ZpeGVkIiwiTWF0aCIsInJvdW5kIiwidG9Mb2NhbGVTdHJpbmciLCJmb3JtYXRGdWxsQ3VycmVuY3kiLCJjdXJyZW50QWdlIiwicmV0aXJlbWVudEFnZSIsInllYXJzVG9SZXRpcmVtZW50IiwiY3VycmVudEFubnVhbEluY29tZSIsImluY29tZUdyb3d0aFJhdGUiLCJpbmNvbWVSZXBsYWNlbWVudFJhdGlvIiwidGFyZ2V0TW9udGhseVJldGlyZW1lbnRJbmNvbWUiLCJtb250aGx5R292ZXJubWVudEJlbmVmaXRzIiwibmV0UmVxdWlyZWRNb250aGx5V2l0aGRyYXdhbCIsImN1cnJlbnRTYXZpbmdzIiwibW9udGhseUNvbnRyaWJ1dGlvbnMiLCJleHBlY3RlZFJldHVybiIsInByb2plY3RlZFNhdmluZ3MiLCJtb250aGx5SW5jb21lRnJvbVNhdmluZ3MiLCJzZXRGb250U2l6ZSIsInNldFRleHRDb2xvciIsInRleHQiLCJEYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwicGVyc29uYWxJbmZvIiwieVBvcyIsImZvckVhY2giLCJsYWJlbCIsInJldGlyZW1lbnRHb2FscyIsImN1cnJlbnRQb3NpdGlvbiIsImV4cGVjdGVkUmV0dXJuVHlwZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJwcm9qZWN0aW9uUmVzdWx0cyIsIm1pbiIsIm1heCIsImFkZFBhZ2UiLCJwcmVSZXRpcmVtZW50RGF0YSIsImN1cnJlbnRZZWFyIiwiZ2V0RnVsbFllYXIiLCJpIiwieWVhciIsImFnZSIsImFubnVhbEluY29tZSIsInBvdyIsInllYXJFbmRCYWxhbmNlIiwiaW52ZXN0bWVudFJldHVybiIsInByZXZCYWxhbmNlU3RyIiwicHJldkJhbGFuY2UiLCJwYXJzZUZsb2F0IiwicmVwbGFjZSIsInB1c2giLCJoZWFkIiwiYm9keSIsInN0YXJ0WSIsInRoZW1lIiwiaGVhZFN0eWxlcyIsImZpbGxDb2xvciIsInRleHRDb2xvciIsImZvbnRTaXplIiwiYm9keVN0eWxlcyIsImNvbHVtblN0eWxlcyIsImNlbGxXaWR0aCIsInBvc3RSZXRpcmVtZW50RGF0YSIsInJlbWFpbmluZ0JhbGFuY2UiLCJhbm51YWxXaXRoZHJhd2FsIiwibW9udGhseVdpdGhkcmF3YWwiLCJiYWxhbmNlQWZ0ZXJXaXRoZHJhd2FsIiwiZ3Jvd3RoT25SZW1haW5pbmdCYWxhbmNlIiwicGFnZUNvdW50IiwiaW50ZXJuYWwiLCJnZXROdW1iZXJPZlBhZ2VzIiwic2V0UGFnZSIsInNhdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/pdfGenerator.js\n"));

/***/ })

});