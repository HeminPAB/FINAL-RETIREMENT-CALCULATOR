"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/pdfGenerator.js":
/*!*********************************!*\
  !*** ./app/lib/pdfGenerator.js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateRetirementReport: function() { return /* binding */ generateRetirementReport; }\n/* harmony export */ });\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jspdf */ \"(app-pages-browser)/./node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jspdf-autotable */ \"(app-pages-browser)/./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs\");\n\n\nconst generateRetirementReport = (formData, calculations)=>{\n    var _formData_expectedReturnType, _formData_expectedReturnType1;\n    const doc = new jspdf__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    // Helper function to format currency\n    const formatCurrency = (value)=>{\n        if (value >= 1000000) {\n            return \"$\".concat((value / 1000000).toFixed(1), \"M\");\n        } else if (value >= 1000) {\n            return \"$\".concat((value / 1000).toFixed(0), \"K\");\n        } else {\n            return \"$\".concat(Math.round(value).toLocaleString());\n        }\n    };\n    const formatFullCurrency = (value)=>{\n        return \"$\".concat(Math.round(value).toLocaleString());\n    };\n    // Extract calculations\n    const { currentAge, retirementAge, yearsToRetirement, currentAnnualIncome, incomeGrowthRate, incomeReplacementRatio, targetMonthlyRetirementIncome, monthlyGovernmentBenefits, netRequiredMonthlyWithdrawal, currentSavings, monthlyContributions, expectedReturn, projectedSavings, monthlyIncomeFromSavings } = calculations;\n    // PAGE 1: SUMMARY\n    doc.setFontSize(20);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Retirement Planning Report\", 20, 30);\n    doc.setFontSize(12);\n    doc.setTextColor(100, 100, 100);\n    doc.text(\"Generated on \".concat(new Date().toLocaleDateString()), 20, 40);\n    // Personal Information Section\n    doc.setFontSize(16);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Personal Information\", 20, 60);\n    doc.setFontSize(11);\n    doc.setTextColor(60, 60, 60);\n    const personalInfo = [\n        [\n            \"Current Age:\",\n            \"\".concat(currentAge, \" years\")\n        ],\n        [\n            \"Retirement Age:\",\n            \"\".concat(retirementAge, \" years\")\n        ],\n        [\n            \"Years to Retirement:\",\n            \"\".concat(yearsToRetirement, \" years\")\n        ],\n        [\n            \"Current Annual Income:\",\n            formatFullCurrency(currentAnnualIncome)\n        ],\n        [\n            \"Income Growth Rate:\",\n            \"\".concat((incomeGrowthRate * 100).toFixed(1), \"%\")\n        ]\n    ];\n    let yPos = 70;\n    personalInfo.forEach((param)=>{\n        let [label, value] = param;\n        doc.text(label, 25, yPos);\n        doc.text(value, 120, yPos);\n        yPos += 8;\n    });\n    // Retirement Goals Section\n    doc.setFontSize(16);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Retirement Goals\", 20, yPos + 10);\n    doc.setFontSize(11);\n    doc.setTextColor(60, 60, 60);\n    yPos += 20;\n    const retirementGoals = [\n        [\n            \"Income Replacement Target:\",\n            \"\".concat(Math.round(incomeReplacementRatio), \"%\")\n        ],\n        [\n            \"Target Monthly Retirement Income:\",\n            formatFullCurrency(targetMonthlyRetirementIncome)\n        ],\n        [\n            \"Monthly Government Benefits:\",\n            formatFullCurrency(monthlyGovernmentBenefits)\n        ],\n        [\n            \"Required Monthly Withdrawal:\",\n            formatFullCurrency(netRequiredMonthlyWithdrawal)\n        ]\n    ];\n    retirementGoals.forEach((param)=>{\n        let [label, value] = param;\n        doc.text(label, 25, yPos);\n        doc.text(value, 120, yPos);\n        yPos += 8;\n    });\n    // Current Financial Position Section\n    doc.setFontSize(16);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Current Financial Position\", 20, yPos + 10);\n    doc.setFontSize(11);\n    doc.setTextColor(60, 60, 60);\n    yPos += 20;\n    const currentPosition = [\n        [\n            \"Current Total Savings:\",\n            formatFullCurrency(currentSavings)\n        ],\n        [\n            \"Monthly Contributions:\",\n            formatFullCurrency(monthlyContributions)\n        ],\n        [\n            \"Expected Return:\",\n            \"\".concat((expectedReturn * 100).toFixed(1), \"%\")\n        ],\n        [\n            \"Investment Risk Profile:\",\n            ((_formData_expectedReturnType = formData.expectedReturnType) === null || _formData_expectedReturnType === void 0 ? void 0 : _formData_expectedReturnType.charAt(0).toUpperCase()) + ((_formData_expectedReturnType1 = formData.expectedReturnType) === null || _formData_expectedReturnType1 === void 0 ? void 0 : _formData_expectedReturnType1.slice(1)) || \"Not specified\"\n        ]\n    ];\n    currentPosition.forEach((param)=>{\n        let [label, value] = param;\n        doc.text(label, 25, yPos);\n        doc.text(value, 120, yPos);\n        yPos += 8;\n    });\n    // Projection Results Section\n    doc.setFontSize(16);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Projection Results\", 20, yPos + 10);\n    doc.setFontSize(11);\n    doc.setTextColor(60, 60, 60);\n    yPos += 20;\n    const projectionResults = [\n        [\n            \"Projected Savings at Retirement:\",\n            formatCurrency(projectedSavings)\n        ],\n        [\n            \"Monthly Income from Savings:\",\n            formatFullCurrency(monthlyIncomeFromSavings)\n        ],\n        [\n            \"Total Monthly Retirement Income:\",\n            formatFullCurrency(monthlyIncomeFromSavings + monthlyGovernmentBenefits)\n        ],\n        [\n            \"Sustainability Rate:\",\n            \"\".concat(Math.min(100, Math.max(0, monthlyIncomeFromSavings / netRequiredMonthlyWithdrawal * 100)).toFixed(1), \"%\")\n        ]\n    ];\n    projectionResults.forEach((param)=>{\n        let [label, value] = param;\n        doc.text(label, 25, yPos);\n        doc.text(value, 120, yPos);\n        yPos += 8;\n    });\n    // PAGE 2: PRE-RETIREMENT PROJECTIONS\n    doc.addPage();\n    doc.setFontSize(20);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Year-by-Year Projections\", 20, 30);\n    doc.setFontSize(14);\n    doc.text(\"Pre-Retirement Phase\", 20, 45);\n    // Generate year-by-year data for pre-retirement\n    const preRetirementData = [];\n    const currentYear = new Date().getFullYear();\n    for(let i = 0; i <= yearsToRetirement; i++){\n        const year = currentYear + i;\n        const age = currentAge + i;\n        const annualIncome = currentAnnualIncome * Math.pow(1 + incomeGrowthRate, i);\n        // Calculate year-end balance with compound interest\n        let yearEndBalance = 0;\n        let investmentReturn = 0;\n        if (i === 0) {\n            investmentReturn = currentSavings * expectedReturn;\n            yearEndBalance = currentSavings * (1 + expectedReturn) + monthlyContributions * 12;\n        } else {\n            // Previous year's balance - need to extract numeric value from formatted string\n            const prevBalanceStr = preRetirementData[i - 1][5];\n            const prevBalance = parseFloat(prevBalanceStr.replace(/[$,]/g, \"\"));\n            investmentReturn = prevBalance * expectedReturn;\n            yearEndBalance = prevBalance * (1 + expectedReturn) + monthlyContributions * 12;\n        }\n        preRetirementData.push([\n            year,\n            age,\n            formatFullCurrency(annualIncome),\n            formatFullCurrency(monthlyContributions * 12),\n            formatFullCurrency(investmentReturn),\n            formatFullCurrency(yearEndBalance)\n        ]);\n    }\n    // Create table for pre-retirement projections\n    (0,jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(doc, {\n        head: [\n            [\n                \"Year\",\n                \"Age\",\n                \"Annual Income\",\n                \"Annual Contribution\",\n                \"Investment Return\",\n                \"Year-End Balance\"\n            ]\n        ],\n        body: preRetirementData,\n        startY: 55,\n        theme: \"grid\",\n        headStyles: {\n            fillColor: [\n                41,\n                128,\n                185\n            ],\n            textColor: 255,\n            fontSize: 10\n        },\n        bodyStyles: {\n            fontSize: 9\n        },\n        columnStyles: {\n            0: {\n                cellWidth: 25\n            },\n            1: {\n                cellWidth: 25\n            },\n            2: {\n                cellWidth: 35\n            },\n            3: {\n                cellWidth: 35\n            },\n            4: {\n                cellWidth: 35\n            },\n            5: {\n                cellWidth: 35\n            }\n        }\n    });\n    // PAGE 3: POST-RETIREMENT WITHDRAWALS\n    doc.addPage();\n    doc.setFontSize(20);\n    doc.setTextColor(40, 40, 40);\n    doc.text(\"Post-Retirement Withdrawals\", 20, 30);\n    doc.setFontSize(14);\n    doc.text(\"Retirement Phase (Age 70-95)\", 20, 45);\n    // Generate post-retirement withdrawal data\n    const postRetirementData = [];\n    let remainingBalance = projectedSavings;\n    const annualWithdrawal = netRequiredMonthlyWithdrawal * 12;\n    const monthlyWithdrawal = netRequiredMonthlyWithdrawal;\n    for(let age = retirementAge; age <= 95; age++){\n        const year = currentYear + (age - currentAge);\n        // Calculate balance after withdrawal and growth\n        const balanceAfterWithdrawal = Math.max(0, remainingBalance - annualWithdrawal);\n        const growthOnRemainingBalance = balanceAfterWithdrawal * expectedReturn;\n        const yearEndBalance = balanceAfterWithdrawal + growthOnRemainingBalance;\n        postRetirementData.push([\n            year,\n            age,\n            formatFullCurrency(annualWithdrawal),\n            formatFullCurrency(monthlyWithdrawal),\n            formatFullCurrency(growthOnRemainingBalance),\n            formatFullCurrency(yearEndBalance)\n        ]);\n        remainingBalance = yearEndBalance;\n        // Stop if balance reaches zero\n        if (remainingBalance <= 0) break;\n    }\n    // Create table for post-retirement withdrawals\n    doc.autoTable({\n        head: [\n            [\n                \"Year\",\n                \"Age\",\n                \"Annual Withdrawal\",\n                \"Monthly Withdrawal\",\n                \"Investment Growth\",\n                \"Year-End Balance\"\n            ]\n        ],\n        body: postRetirementData,\n        startY: 55,\n        theme: \"grid\",\n        headStyles: {\n            fillColor: [\n                231,\n                76,\n                60\n            ],\n            textColor: 255,\n            fontSize: 10\n        },\n        bodyStyles: {\n            fontSize: 9\n        },\n        columnStyles: {\n            0: {\n                cellWidth: 25\n            },\n            1: {\n                cellWidth: 25\n            },\n            2: {\n                cellWidth: 35\n            },\n            3: {\n                cellWidth: 35\n            },\n            4: {\n                cellWidth: 35\n            },\n            5: {\n                cellWidth: 35\n            }\n        }\n    });\n    // Add footer to all pages\n    const pageCount = doc.internal.getNumberOfPages();\n    for(let i = 1; i <= pageCount; i++){\n        doc.setPage(i);\n        doc.setFontSize(8);\n        doc.setTextColor(150, 150, 150);\n        doc.text(\"Page \".concat(i, \" of \").concat(pageCount), 20, 285);\n        doc.text(\"This report is for illustrative purposes only and should not be considered as financial advice.\", 20, 292);\n    }\n    // Save the PDF\n    doc.save(\"retirement-planning-report.pdf\");\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvcGRmR2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQjtBQUNjO0FBRWpDLE1BQU1FLDJCQUEyQixDQUFDQyxVQUFVQztRQW9HbEJELDhCQUF1REE7SUFuR3RGLE1BQU1FLE1BQU0sSUFBSUwsNkNBQUtBO0lBRXJCLHFDQUFxQztJQUNyQyxNQUFNTSxpQkFBaUIsQ0FBQ0M7UUFDdEIsSUFBSUEsU0FBUyxTQUFTO1lBQ3BCLE9BQU8sSUFBaUMsT0FBN0IsQ0FBQ0EsUUFBUSxPQUFNLEVBQUdDLE9BQU8sQ0FBQyxJQUFHO1FBQzFDLE9BQU8sSUFBSUQsU0FBUyxNQUFNO1lBQ3hCLE9BQU8sSUFBOEIsT0FBMUIsQ0FBQ0EsUUFBUSxJQUFHLEVBQUdDLE9BQU8sQ0FBQyxJQUFHO1FBQ3ZDLE9BQU87WUFDTCxPQUFPLElBQXVDLE9BQW5DQyxLQUFLQyxLQUFLLENBQUNILE9BQU9JLGNBQWM7UUFDN0M7SUFDRjtJQUVBLE1BQU1DLHFCQUFxQixDQUFDTDtRQUMxQixPQUFPLElBQXVDLE9BQW5DRSxLQUFLQyxLQUFLLENBQUNILE9BQU9JLGNBQWM7SUFDN0M7SUFFQSx1QkFBdUI7SUFDdkIsTUFBTSxFQUNKRSxVQUFVLEVBQ1ZDLGFBQWEsRUFDYkMsaUJBQWlCLEVBQ2pCQyxtQkFBbUIsRUFDbkJDLGdCQUFnQixFQUNoQkMsc0JBQXNCLEVBQ3RCQyw2QkFBNkIsRUFDN0JDLHlCQUF5QixFQUN6QkMsNEJBQTRCLEVBQzVCQyxjQUFjLEVBQ2RDLG9CQUFvQixFQUNwQkMsY0FBYyxFQUNkQyxnQkFBZ0IsRUFDaEJDLHdCQUF3QixFQUN6QixHQUFHdEI7SUFFSixrQkFBa0I7SUFDbEJDLElBQUlzQixXQUFXLENBQUM7SUFDaEJ0QixJQUFJdUIsWUFBWSxDQUFDLElBQUksSUFBSTtJQUN6QnZCLElBQUl3QixJQUFJLENBQUMsOEJBQThCLElBQUk7SUFFM0N4QixJQUFJc0IsV0FBVyxDQUFDO0lBQ2hCdEIsSUFB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UUFDM0dDLE1BQU1VO1FBQ05ULFFBQVE7UUFDUkMsT0FBTztRQUNQQyxZQUFZO1lBQUVDLFdBQVc7Z0JBQUM7Z0JBQUs7Z0JBQUk7YUFBRztZQUFFQyxXQUFXO1lBQUtDLFVBQVU7UUFBRztRQUNyRUMsWUFBWTtZQUFFRCxVQUFVO1FBQUU7UUFDMUJFLGNBQWM7WUFDWixHQUFHO2dCQUFFQyxXQUFXO1lBQUc7WUFDbkIsR0FBRztnQkFBRUEsV0FBVztZQUFHO1lBQ25CLEdBQUc7Z0JBQUVBLFdBQVc7WUFBRztZQUNuQixHQUFHO2dCQUFFQSxXQUFXO1lBQUc7WUFDbkIsR0FBRztnQkFBRUEsV0FBVztZQUFHO1lBQ25CLEdBQUc7Z0JBQUVBLFdBQVc7WUFBRztRQUNyQjtJQUNGO0lBRUEsMEJBQTBCO0lBQzFCLE1BQU1PLFlBQVl6RSxJQUFJMEUsUUFBUSxDQUFDQyxnQkFBZ0I7SUFDL0MsSUFBSyxJQUFJL0IsSUFBSSxHQUFHQSxLQUFLNkIsV0FBVzdCLElBQUs7UUFDbkM1QyxJQUFJNEUsT0FBTyxDQUFDaEM7UUFDWjVDLElBQUlzQixXQUFXLENBQUM7UUFDaEJ0QixJQUFJdUIsWUFBWSxDQUFDLEtBQUssS0FBSztRQUMzQnZCLElBQUl3QixJQUFJLENBQUMsUUFBZ0JpRCxPQUFSN0IsR0FBRSxRQUFnQixPQUFWNkIsWUFBYSxJQUFJO1FBQzFDekUsSUFBSXdCLElBQUksQ0FBQyxtR0FBbUcsSUFBSTtJQUNsSDtJQUVBLGVBQWU7SUFDZnhCLElBQUk2RSxJQUFJLENBQUM7QUFDWCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvcGRmR2VuZXJhdG9yLmpzPzA3MjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGpzUERGIGZyb20gJ2pzcGRmJztcbmltcG9ydCBhdXRvVGFibGUgZnJvbSAnanNwZGYtYXV0b3RhYmxlJztcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlUmV0aXJlbWVudFJlcG9ydCA9IChmb3JtRGF0YSwgY2FsY3VsYXRpb25zKSA9PiB7XG4gIGNvbnN0IGRvYyA9IG5ldyBqc1BERigpO1xuICBcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZvcm1hdCBjdXJyZW5jeVxuICBjb25zdCBmb3JtYXRDdXJyZW5jeSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA+PSAxMDAwMDAwKSB7XG4gICAgICByZXR1cm4gYCQkeyh2YWx1ZSAvIDEwMDAwMDApLnRvRml4ZWQoMSl9TWA7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA+PSAxMDAwKSB7XG4gICAgICByZXR1cm4gYCQkeyh2YWx1ZSAvIDEwMDApLnRvRml4ZWQoMCl9S2A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgJCR7TWF0aC5yb3VuZCh2YWx1ZSkudG9Mb2NhbGVTdHJpbmcoKX1gO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBmb3JtYXRGdWxsQ3VycmVuY3kgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gYCQke01hdGgucm91bmQodmFsdWUpLnRvTG9jYWxlU3RyaW5nKCl9YDtcbiAgfTtcblxuICAvLyBFeHRyYWN0IGNhbGN1bGF0aW9uc1xuICBjb25zdCB7XG4gICAgY3VycmVudEFnZSxcbiAgICByZXRpcmVtZW50QWdlLFxuICAgIHllYXJzVG9SZXRpcmVtZW50LFxuICAgIGN1cnJlbnRBbm51YWxJbmNvbWUsXG4gICAgaW5jb21lR3Jvd3RoUmF0ZSxcbiAgICBpbmNvbWVSZXBsYWNlbWVudFJhdGlvLFxuICAgIHRhcmdldE1vbnRobHlSZXRpcmVtZW50SW5jb21lLFxuICAgIG1vbnRobHlHb3Zlcm5tZW50QmVuZWZpdHMsXG4gICAgbmV0UmVxdWlyZWRNb250aGx5V2l0aGRyYXdhbCxcbiAgICBjdXJyZW50U2F2aW5ncyxcbiAgICBtb250aGx5Q29udHJpYnV0aW9ucyxcbiAgICBleHBlY3RlZFJldHVybixcbiAgICBwcm9qZWN0ZWRTYXZpbmdzLFxuICAgIG1vbnRobHlJbmNvbWVGcm9tU2F2aW5nc1xuICB9ID0gY2FsY3VsYXRpb25zO1xuXG4gIC8vIFBBR0UgMTogU1VNTUFSWVxuICBkb2Muc2V0Rm9udFNpemUoMjApO1xuICBkb2Muc2V0VGV4dENvbG9yKDQwLCA0MCwgNDApO1xuICBkb2MudGV4dCgnUmV0aXJlbWVudCBQbGFubmluZyBSZXBvcnQnLCAyMCwgMzApO1xuICBcbiAgZG9jLnNldEZvbnRTaXplKDEyKTtcbiAgZG9jLnNldFRleHRDb2xvcigxMDAsIDEwMCwgMTAwKTtcbiAgZG9jLnRleHQoYEdlbmVyYXRlZCBvbiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9YCwgMjAsIDQwKTtcblxuICAvLyBQZXJzb25hbCBJbmZvcm1hdGlvbiBTZWN0aW9uXG4gIGRvYy5zZXRGb250U2l6ZSgxNik7XG4gIGRvYy5zZXRUZXh0Q29sb3IoNDAsIDQwLCA0MCk7XG4gIGRvYy50ZXh0KCdQZXJzb25hbCBJbmZvcm1hdGlvbicsIDIwLCA2MCk7XG4gIFxuICBkb2Muc2V0Rm9udFNpemUoMTEpO1xuICBkb2Muc2V0VGV4dENvbG9yKDYwLCA2MCwgNjApO1xuICBjb25zdCBwZXJzb25hbEluZm8gPSBbXG4gICAgWydDdXJyZW50IEFnZTonLCBgJHtjdXJyZW50QWdlfSB5ZWFyc2BdLFxuICAgIFsnUmV0aXJlbWVudCBBZ2U6JywgYCR7cmV0aXJlbWVudEFnZX0geWVhcnNgXSxcbiAgICBbJ1llYXJzIHRvIFJldGlyZW1lbnQ6JywgYCR7eWVhcnNUb1JldGlyZW1lbnR9IHllYXJzYF0sXG4gICAgWydDdXJyZW50IEFubnVhbCBJbmNvbWU6JywgZm9ybWF0RnVsbEN1cnJlbmN5KGN1cnJlbnRBbm51YWxJbmNvbWUpXSxcbiAgICBbJ0luY29tZSBHcm93dGggUmF0ZTonLCBgJHsoaW5jb21lR3Jvd3RoUmF0ZSAqIDEwMCkudG9GaXhlZCgxKX0lYF1cbiAgXTtcbiAgXG4gIGxldCB5UG9zID0gNzA7XG4gIHBlcnNvbmFsSW5mby5mb3JFYWNoKChbbGFiZWwsIHZhbHVlXSkgPT4ge1xuICAgIGRvYy50ZXh0KGxhYmVsLCAyNSwgeVBvcyk7XG4gICAgZG9jLnRleHQodmFsdWUsIDEyMCwgeVBvcyk7XG4gICAgeVBvcyArPSA4O1xuICB9KTtcblxuICAvLyBSZXRpcmVtZW50IEdvYWxzIFNlY3Rpb25cbiAgZG9jLnNldEZvbnRTaXplKDE2KTtcbiAgZG9jLnNldFRleHRDb2xvcig0MCwgNDAsIDQwKTtcbiAgZG9jLnRleHQoJ1JldGlyZW1lbnQgR29hbHMnLCAyMCwgeVBvcyArIDEwKTtcbiAgXG4gIGRvYy5zZXRGb250U2l6ZSgxMSk7XG4gIGRvYy5zZXRUZXh0Q29sb3IoNjAsIDYwLCA2MCk7XG4gIHlQb3MgKz0gMjA7XG4gIGNvbnN0IHJldGlyZW1lbnRHb2FscyA9IFtcbiAgICBbJ0luY29tZSBSZXBsYWNlbWVudCBUYXJnZXQ6JywgYCR7TWF0aC5yb3VuZChpbmNvbWVSZXBsYWNlbWVudFJhdGlvKX0lYF0sXG4gICAgWydUYXJnZXQgTW9udGhseSBSZXRpcmVtZW50IEluY29tZTonLCBmb3JtYXRGdWxsQ3VycmVuY3kodGFyZ2V0TW9udGhseVJldGlyZW1lbnRJbmNvbWUpXSxcbiAgICBbJ01vbnRobHkgR292ZXJubWVudCBCZW5lZml0czonLCBmb3JtYXRGdWxsQ3VycmVuY3kobW9udGhseUdvdmVybm1lbnRCZW5lZml0cyldLFxuICAgIFsnUmVxdWlyZWQgTW9udGhseSBXaXRoZHJhd2FsOicsIGZvcm1hdEZ1bGxDdXJyZW5jeShuZXRSZXF1aXJlZE1vbnRobHlXaXRoZHJhd2FsKV1cbiAgXTtcbiAgXG4gIHJldGlyZW1lbnRHb2Fscy5mb3JFYWNoKChbbGFiZWwsIHZhbHVlXSkgPT4ge1xuICAgIGRvYy50ZXh0KGxhYmVsLCAyNSwgeVBvcyk7XG4gICAgZG9jLnRleHQodmFsdWUsIDEyMCwgeVBvcyk7XG4gICAgeVBvcyArPSA4O1xuICB9KTtcblxuICAvLyBDdXJyZW50IEZpbmFuY2lhbCBQb3NpdGlvbiBTZWN0aW9uXG4gIGRvYy5zZXRGb250U2l6ZSgxNik7XG4gIGRvYy5zZXRUZXh0Q29sb3IoNDAsIDQwLCA0MCk7XG4gIGRvYy50ZXh0KCdDdXJyZW50IEZpbmFuY2lhbCBQb3NpdGlvbicsIDIwLCB5UG9zICsgMTApO1xuICBcbiAgZG9jLnNldEZvbnRTaXplKDExKTtcbiAgZG9jLnNldFRleHRDb2xvcig2MCwgNjAsIDYwKTtcbiAgeVBvcyArPSAyMDtcbiAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gW1xuICAgIFsnQ3VycmVudCBUb3RhbCBTYXZpbmdzOicsIGZvcm1hdEZ1bGxDdXJyZW5jeShjdXJyZW50U2F2aW5ncyldLFxuICAgIFsnTW9udGhseSBDb250cmlidXRpb25zOicsIGZvcm1hdEZ1bGxDdXJyZW5jeShtb250aGx5Q29udHJpYnV0aW9ucyldLFxuICAgIFsnRXhwZWN0ZWQgUmV0dXJuOicsIGAkeyhleHBlY3RlZFJldHVybiAqIDEwMCkudG9GaXhlZCgxKX0lYF0sXG4gICAgWydJbnZlc3RtZW50IFJpc2sgUHJvZmlsZTonLCBmb3JtRGF0YS5leHBlY3RlZFJldHVyblR5cGU/LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZm9ybURhdGEuZXhwZWN0ZWRSZXR1cm5UeXBlPy5zbGljZSgxKSB8fCAnTm90IHNwZWNpZmllZCddXG4gIF07XG4gIFxuICBjdXJyZW50UG9zaXRpb24uZm9yRWFjaCgoW2xhYmVsLCB2YWx1ZV0pID0+IHtcbiAgICBkb2MudGV4dChsYWJlbCwgMjUsIHlQb3MpO1xuICAgIGRvYy50ZXh0KHZhbHVlLCAxMjAsIHlQb3MpO1xuICAgIHlQb3MgKz0gODtcbiAgfSk7XG5cbiAgLy8gUHJvamVjdGlvbiBSZXN1bHRzIFNlY3Rpb25cbiAgZG9jLnNldEZvbnRTaXplKDE2KTtcbiAgZG9jLnNldFRleHRDb2xvcig0MCwgNDAsIDQwKTtcbiAgZG9jLnRleHQoJ1Byb2plY3Rpb24gUmVzdWx0cycsIDIwLCB5UG9zICsgMTApO1xuICBcbiAgZG9jLnNldEZvbnRTaXplKDExKTtcbiAgZG9jLnNldFRleHRDb2xvcig2MCwgNjAsIDYwKTtcbiAgeVBvcyArPSAyMDtcbiAgY29uc3QgcHJvamVjdGlvblJlc3VsdHMgPSBbXG4gICAgWydQcm9qZWN0ZWQgU2F2aW5ncyBhdCBSZXRpcmVtZW50OicsIGZvcm1hdEN1cnJlbmN5KHByb2plY3RlZFNhdmluZ3MpXSxcbiAgICBbJ01vbnRobHkgSW5jb21lIGZyb20gU2F2aW5nczonLCBmb3JtYXRGdWxsQ3VycmVuY3kobW9udGhseUluY29tZUZyb21TYXZpbmdzKV0sXG4gICAgWydUb3RhbCBNb250aGx5IFJldGlyZW1lbnQgSW5jb21lOicsIGZvcm1hdEZ1bGxDdXJyZW5jeShtb250aGx5SW5jb21lRnJvbVNhdmluZ3MgKyBtb250aGx5R292ZXJubWVudEJlbmVmaXRzKV0sXG4gICAgWydTdXN0YWluYWJpbGl0eSBSYXRlOicsIGAke01hdGgubWluKDEwMCwgTWF0aC5tYXgoMCwgKG1vbnRobHlJbmNvbWVGcm9tU2F2aW5ncyAvIG5ldFJlcXVpcmVkTW9udGhseVdpdGhkcmF3YWwpICogMTAwKSkudG9GaXhlZCgxKX0lYF1cbiAgXTtcbiAgXG4gIHByb2plY3Rpb25SZXN1bHRzLmZvckVhY2goKFtsYWJlbCwgdmFsdWVdKSA9PiB7XG4gICAgZG9jLnRleHQobGFiZWwsIDI1LCB5UG9zKTtcbiAgICBkb2MudGV4dCh2YWx1ZSwgMTIwLCB5UG9zKTtcbiAgICB5UG9zICs9IDg7XG4gIH0pO1xuXG4gIC8vIFBBR0UgMjogUFJFLVJFVElSRU1FTlQgUFJPSkVDVElPTlNcbiAgZG9jLmFkZFBhZ2UoKTtcbiAgZG9jLnNldEZvbnRTaXplKDIwKTtcbiAgZG9jLnNldFRleHRDb2xvcig0MCwgNDAsIDQwKTtcbiAgZG9jLnRleHQoJ1llYXItYnktWWVhciBQcm9qZWN0aW9ucycsIDIwLCAzMCk7XG4gIFxuICBkb2Muc2V0Rm9udFNpemUoMTQpO1xuICBkb2MudGV4dCgnUHJlLVJldGlyZW1lbnQgUGhhc2UnLCAyMCwgNDUpO1xuXG4gIC8vIEdlbmVyYXRlIHllYXItYnkteWVhciBkYXRhIGZvciBwcmUtcmV0aXJlbWVudFxuICBjb25zdCBwcmVSZXRpcmVtZW50RGF0YSA9IFtdO1xuICBjb25zdCBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHllYXJzVG9SZXRpcmVtZW50OyBpKyspIHtcbiAgICBjb25zdCB5ZWFyID0gY3VycmVudFllYXIgKyBpO1xuICAgIGNvbnN0IGFnZSA9IGN1cnJlbnRBZ2UgKyBpO1xuICAgIGNvbnN0IGFubnVhbEluY29tZSA9IGN1cnJlbnRBbm51YWxJbmNvbWUgKiBNYXRoLnBvdygxICsgaW5jb21lR3Jvd3RoUmF0ZSwgaSk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHllYXItZW5kIGJhbGFuY2Ugd2l0aCBjb21wb3VuZCBpbnRlcmVzdFxuICAgIGxldCB5ZWFyRW5kQmFsYW5jZSA9IDA7XG4gICAgbGV0IGludmVzdG1lbnRSZXR1cm4gPSAwO1xuICAgIFxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBpbnZlc3RtZW50UmV0dXJuID0gY3VycmVudFNhdmluZ3MgKiBleHBlY3RlZFJldHVybjtcbiAgICAgIHllYXJFbmRCYWxhbmNlID0gY3VycmVudFNhdmluZ3MgKiAoMSArIGV4cGVjdGVkUmV0dXJuKSArIChtb250aGx5Q29udHJpYnV0aW9ucyAqIDEyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHJldmlvdXMgeWVhcidzIGJhbGFuY2UgLSBuZWVkIHRvIGV4dHJhY3QgbnVtZXJpYyB2YWx1ZSBmcm9tIGZvcm1hdHRlZCBzdHJpbmdcbiAgICAgIGNvbnN0IHByZXZCYWxhbmNlU3RyID0gcHJlUmV0aXJlbWVudERhdGFbaS0xXVs1XTtcbiAgICAgIGNvbnN0IHByZXZCYWxhbmNlID0gcGFyc2VGbG9hdChwcmV2QmFsYW5jZVN0ci5yZXBsYWNlKC9bJCxdL2csICcnKSk7XG4gICAgICBpbnZlc3RtZW50UmV0dXJuID0gcHJldkJhbGFuY2UgKiBleHBlY3RlZFJldHVybjtcbiAgICAgIHllYXJFbmRCYWxhbmNlID0gcHJldkJhbGFuY2UgKiAoMSArIGV4cGVjdGVkUmV0dXJuKSArIChtb250aGx5Q29udHJpYnV0aW9ucyAqIDEyKTtcbiAgICB9XG4gICAgXG4gICAgcHJlUmV0aXJlbWVudERhdGEucHVzaChbXG4gICAgICB5ZWFyLFxuICAgICAgYWdlLFxuICAgICAgZm9ybWF0RnVsbEN1cnJlbmN5KGFubnVhbEluY29tZSksXG4gICAgICBmb3JtYXRGdWxsQ3VycmVuY3kobW9udGhseUNvbnRyaWJ1dGlvbnMgKiAxMiksXG4gICAgICBmb3JtYXRGdWxsQ3VycmVuY3koaW52ZXN0bWVudFJldHVybiksXG4gICAgICBmb3JtYXRGdWxsQ3VycmVuY3koeWVhckVuZEJhbGFuY2UpXG4gICAgXSk7XG4gIH1cblxuICAvLyBDcmVhdGUgdGFibGUgZm9yIHByZS1yZXRpcmVtZW50IHByb2plY3Rpb25zXG4gIGF1dG9UYWJsZShkb2MsIHtcbiAgICBoZWFkOiBbWydZZWFyJywgJ0FnZScsICdBbm51YWwgSW5jb21lJywgJ0FubnVhbCBDb250cmlidXRpb24nLCAnSW52ZXN0bWVudCBSZXR1cm4nLCAnWWVhci1FbmQgQmFsYW5jZSddXSxcbiAgICBib2R5OiBwcmVSZXRpcmVtZW50RGF0YSxcbiAgICBzdGFydFk6IDU1LFxuICAgIHRoZW1lOiAnZ3JpZCcsXG4gICAgaGVhZFN0eWxlczogeyBmaWxsQ29sb3I6IFs0MSwgMTI4LCAxODVdLCB0ZXh0Q29sb3I6IDI1NSwgZm9udFNpemU6IDEwIH0sXG4gICAgYm9keVN0eWxlczogeyBmb250U2l6ZTogOSB9LFxuICAgIGNvbHVtblN0eWxlczoge1xuICAgICAgMDogeyBjZWxsV2lkdGg6IDI1IH0sXG4gICAgICAxOiB7IGNlbGxXaWR0aDogMjUgfSxcbiAgICAgIDI6IHsgY2VsbFdpZHRoOiAzNSB9LFxuICAgICAgMzogeyBjZWxsV2lkdGg6IDM1IH0sXG4gICAgICA0OiB7IGNlbGxXaWR0aDogMzUgfSxcbiAgICAgIDU6IHsgY2VsbFdpZHRoOiAzNSB9XG4gICAgfVxuICB9KTtcblxuICAvLyBQQUdFIDM6IFBPU1QtUkVUSVJFTUVOVCBXSVRIRFJBV0FMU1xuICBkb2MuYWRkUGFnZSgpO1xuICBkb2Muc2V0Rm9udFNpemUoMjApO1xuICBkb2Muc2V0VGV4dENvbG9yKDQwLCA0MCwgNDApO1xuICBkb2MudGV4dCgnUG9zdC1SZXRpcmVtZW50IFdpdGhkcmF3YWxzJywgMjAsIDMwKTtcbiAgXG4gIGRvYy5zZXRGb250U2l6ZSgxNCk7XG4gIGRvYy50ZXh0KCdSZXRpcmVtZW50IFBoYXNlIChBZ2UgNzAtOTUpJywgMjAsIDQ1KTtcblxuICAvLyBHZW5lcmF0ZSBwb3N0LXJldGlyZW1lbnQgd2l0aGRyYXdhbCBkYXRhXG4gIGNvbnN0IHBvc3RSZXRpcmVtZW50RGF0YSA9IFtdO1xuICBsZXQgcmVtYWluaW5nQmFsYW5jZSA9IHByb2plY3RlZFNhdmluZ3M7XG4gIGNvbnN0IGFubnVhbFdpdGhkcmF3YWwgPSBuZXRSZXF1aXJlZE1vbnRobHlXaXRoZHJhd2FsICogMTI7XG4gIGNvbnN0IG1vbnRobHlXaXRoZHJhd2FsID0gbmV0UmVxdWlyZWRNb250aGx5V2l0aGRyYXdhbDtcbiAgXG4gIGZvciAobGV0IGFnZSA9IHJldGlyZW1lbnRBZ2U7IGFnZSA8PSA5NTsgYWdlKyspIHtcbiAgICBjb25zdCB5ZWFyID0gY3VycmVudFllYXIgKyAoYWdlIC0gY3VycmVudEFnZSk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGJhbGFuY2UgYWZ0ZXIgd2l0aGRyYXdhbCBhbmQgZ3Jvd3RoXG4gICAgY29uc3QgYmFsYW5jZUFmdGVyV2l0aGRyYXdhbCA9IE1hdGgubWF4KDAsIHJlbWFpbmluZ0JhbGFuY2UgLSBhbm51YWxXaXRoZHJhd2FsKTtcbiAgICBjb25zdCBncm93dGhPblJlbWFpbmluZ0JhbGFuY2UgPSBiYWxhbmNlQWZ0ZXJXaXRoZHJhd2FsICogZXhwZWN0ZWRSZXR1cm47XG4gICAgY29uc3QgeWVhckVuZEJhbGFuY2UgPSBiYWxhbmNlQWZ0ZXJXaXRoZHJhd2FsICsgZ3Jvd3RoT25SZW1haW5pbmdCYWxhbmNlO1xuICAgIFxuICAgIHBvc3RSZXRpcmVtZW50RGF0YS5wdXNoKFtcbiAgICAgIHllYXIsXG4gICAgICBhZ2UsXG4gICAgICBmb3JtYXRGdWxsQ3VycmVuY3koYW5udWFsV2l0aGRyYXdhbCksXG4gICAgICBmb3JtYXRGdWxsQ3VycmVuY3kobW9udGhseVdpdGhkcmF3YWwpLFxuICAgICAgZm9ybWF0RnVsbEN1cnJlbmN5KGdyb3d0aE9uUmVtYWluaW5nQmFsYW5jZSksXG4gICAgICBmb3JtYXRGdWxsQ3VycmVuY3koeWVhckVuZEJhbGFuY2UpXG4gICAgXSk7XG4gICAgXG4gICAgcmVtYWluaW5nQmFsYW5jZSA9IHllYXJFbmRCYWxhbmNlO1xuICAgIFxuICAgIC8vIFN0b3AgaWYgYmFsYW5jZSByZWFjaGVzIHplcm9cbiAgICBpZiAocmVtYWluaW5nQmFsYW5jZSA8PSAwKSBicmVhaztcbiAgfVxuXG4gIC8vIENyZWF0ZSB0YWJsZSBmb3IgcG9zdC1yZXRpcmVtZW50IHdpdGhkcmF3YWxzXG4gIGRvYy5hdXRvVGFibGUoe1xuICAgIGhlYWQ6IFtbJ1llYXInLCAnQWdlJywgJ0FubnVhbCBXaXRoZHJhd2FsJywgJ01vbnRobHkgV2l0aGRyYXdhbCcsICdJbnZlc3RtZW50IEdyb3d0aCcsICdZZWFyLUVuZCBCYWxhbmNlJ11dLFxuICAgIGJvZHk6IHBvc3RSZXRpcmVtZW50RGF0YSxcbiAgICBzdGFydFk6IDU1LFxuICAgIHRoZW1lOiAnZ3JpZCcsXG4gICAgaGVhZFN0eWxlczogeyBmaWxsQ29sb3I6IFsyMzEsIDc2LCA2MF0sIHRleHRDb2xvcjogMjU1LCBmb250U2l6ZTogMTAgfSxcbiAgICBib2R5U3R5bGVzOiB7IGZvbnRTaXplOiA5IH0sXG4gICAgY29sdW1uU3R5bGVzOiB7XG4gICAgICAwOiB7IGNlbGxXaWR0aDogMjUgfSxcbiAgICAgIDE6IHsgY2VsbFdpZHRoOiAyNSB9LFxuICAgICAgMjogeyBjZWxsV2lkdGg6IDM1IH0sXG4gICAgICAzOiB7IGNlbGxXaWR0aDogMzUgfSxcbiAgICAgIDQ6IHsgY2VsbFdpZHRoOiAzNSB9LFxuICAgICAgNTogeyBjZWxsV2lkdGg6IDM1IH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIEFkZCBmb290ZXIgdG8gYWxsIHBhZ2VzXG4gIGNvbnN0IHBhZ2VDb3VudCA9IGRvYy5pbnRlcm5hbC5nZXROdW1iZXJPZlBhZ2VzKCk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IHBhZ2VDb3VudDsgaSsrKSB7XG4gICAgZG9jLnNldFBhZ2UoaSk7XG4gICAgZG9jLnNldEZvbnRTaXplKDgpO1xuICAgIGRvYy5zZXRUZXh0Q29sb3IoMTUwLCAxNTAsIDE1MCk7XG4gICAgZG9jLnRleHQoYFBhZ2UgJHtpfSBvZiAke3BhZ2VDb3VudH1gLCAyMCwgMjg1KTtcbiAgICBkb2MudGV4dCgnVGhpcyByZXBvcnQgaXMgZm9yIGlsbHVzdHJhdGl2ZSBwdXJwb3NlcyBvbmx5IGFuZCBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgYXMgZmluYW5jaWFsIGFkdmljZS4nLCAyMCwgMjkyKTtcbiAgfVxuXG4gIC8vIFNhdmUgdGhlIFBERlxuICBkb2Muc2F2ZSgncmV0aXJlbWVudC1wbGFubmluZy1yZXBvcnQucGRmJyk7XG59OyAiXSwibmFtZXMiOlsianNQREYiLCJhdXRvVGFibGUiLCJnZW5lcmF0ZVJldGlyZW1lbnRSZXBvcnQiLCJmb3JtRGF0YSIsImNhbGN1bGF0aW9ucyIsImRvYyIsImZvcm1hdEN1cnJlbmN5IiwidmFsdWUiLCJ0b0ZpeGVkIiwiTWF0aCIsInJvdW5kIiwidG9Mb2NhbGVTdHJpbmciLCJmb3JtYXRGdWxsQ3VycmVuY3kiLCJjdXJyZW50QWdlIiwicmV0aXJlbWVudEFnZSIsInllYXJzVG9SZXRpcmVtZW50IiwiY3VycmVudEFubnVhbEluY29tZSIsImluY29tZUdyb3d0aFJhdGUiLCJpbmNvbWVSZXBsYWNlbWVudFJhdGlvIiwidGFyZ2V0TW9udGhseVJldGlyZW1lbnRJbmNvbWUiLCJtb250aGx5R292ZXJubWVudEJlbmVmaXRzIiwibmV0UmVxdWlyZWRNb250aGx5V2l0aGRyYXdhbCIsImN1cnJlbnRTYXZpbmdzIiwibW9udGhseUNvbnRyaWJ1dGlvbnMiLCJleHBlY3RlZFJldHVybiIsInByb2plY3RlZFNhdmluZ3MiLCJtb250aGx5SW5jb21lRnJvbVNhdmluZ3MiLCJzZXRGb250U2l6ZSIsInNldFRleHRDb2xvciIsInRleHQiLCJEYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwicGVyc29uYWxJbmZvIiwieVBvcyIsImZvckVhY2giLCJsYWJlbCIsInJldGlyZW1lbnRHb2FscyIsImN1cnJlbnRQb3NpdGlvbiIsImV4cGVjdGVkUmV0dXJuVHlwZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJwcm9qZWN0aW9uUmVzdWx0cyIsIm1pbiIsIm1heCIsImFkZFBhZ2UiLCJwcmVSZXRpcmVtZW50RGF0YSIsImN1cnJlbnRZZWFyIiwiZ2V0RnVsbFllYXIiLCJpIiwieWVhciIsImFnZSIsImFubnVhbEluY29tZSIsInBvdyIsInllYXJFbmRCYWxhbmNlIiwiaW52ZXN0bWVudFJldHVybiIsInByZXZCYWxhbmNlU3RyIiwicHJldkJhbGFuY2UiLCJwYXJzZUZsb2F0IiwicmVwbGFjZSIsInB1c2giLCJoZWFkIiwiYm9keSIsInN0YXJ0WSIsInRoZW1lIiwiaGVhZFN0eWxlcyIsImZpbGxDb2xvciIsInRleHRDb2xvciIsImZvbnRTaXplIiwiYm9keVN0eWxlcyIsImNvbHVtblN0eWxlcyIsImNlbGxXaWR0aCIsInBvc3RSZXRpcmVtZW50RGF0YSIsInJlbWFpbmluZ0JhbGFuY2UiLCJhbm51YWxXaXRoZHJhd2FsIiwibW9udGhseVdpdGhkcmF3YWwiLCJiYWxhbmNlQWZ0ZXJXaXRoZHJhd2FsIiwiZ3Jvd3RoT25SZW1haW5pbmdCYWxhbmNlIiwicGFnZUNvdW50IiwiaW50ZXJuYWwiLCJnZXROdW1iZXJPZlBhZ2VzIiwic2V0UGFnZSIsInNhdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/pdfGenerator.js\n"));

/***/ })

});